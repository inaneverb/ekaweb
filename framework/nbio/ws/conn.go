package ekaweb_nbiows

import (
	"context"
	"sync/atomic"
	"unsafe"

	"github.com/inaneverb/ekacore/ekaunsafe/v4"
	"github.com/lesismal/nbio/nbhttp/websocket"
)

////////////////////////////////////////////////////////////////////////////////
///// Conn interface implementation of regular connection //////////////////////
////////////////////////////////////////////////////////////////////////////////

type Conn struct {

	// Place variables that are protected by the atomic operations firstly.
	// It allows us to avoid cases with "broken RAM" error for some platforms.

	closeCode   uint32         // protected by atomic ops
	closeDetail unsafe.Pointer // protected by atomic ops

	// ------------------------------------------------------------------- //

	ctx context.Context // taken from the http.Request

	id      string   // generated by the user-specific generator (see Options)
	options *Options // parameters, conn is created with

	originConn *websocket.Conn // nbio WebSocket connection object
}

func (c *Conn) ID() string {
	return c.id
}

func (c *Conn) Context() context.Context {
	return c.ctx
}

func (c *Conn) WriteMessage(typ MessageType, payload []byte) {
	err := c.originConn.WriteMessage(MessageTypeToNbio(typ), payload)
	if err != nil {
		applyErrorHandler(c, err)
	}
}

func (c *Conn) CloseWithCode(cc CloseCode) {
	processCloseMessage(c.originConn, uint16(cc), cc.String())
	_ = c.originConn.Close()
}

// getCloseData returns a close code and detail message that was send/received
// to/from client.
func (c *Conn) getCloseData() (CloseCode, string) {

	if c == nil {
		return CloseCodeInternalError, CloseCodeInternalError.String()
	}

	var cc = CloseCode(atomic.LoadUint32(&c.closeCode))
	var ccDetailPtr = (*string)(atomic.LoadPointer(&c.closeDetail))

	if cc == 0 || ccDetailPtr == nil {
		return CloseCodeNoStatusReceived, CloseCodeNoStatusReceived.String()
	}

	return cc, *ccDetailPtr
}

// setCloseData saves close code and detail message and they will be allowed
// to access using getCloseData later.
// Do nothing if these fields were set already. Nil safe.
func (c *Conn) setCloseData(cc CloseCode, detail string) {

	if c != nil && atomic.CompareAndSwapUint32(&c.closeCode, 0, uint32(cc)) {
		atomic.StorePointer(&c.closeDetail, unsafe.Pointer(&detail))
	}
}

func makeConn(
	ctx context.Context,
	options *Options, originConn *websocket.Conn) *Conn {

	conn := Conn{
		id:         options.IDGenerator(ctx),
		ctx:        ctx,
		options:    options,
		originConn: originConn,
	}

	originConn.SetSession(&conn)
	return &conn
}

func connFromOrigin(originConn *websocket.Conn) *Conn {
	return (*Conn)(ekaunsafe.UnpackInterface(originConn.Session()).Word)
}

////////////////////////////////////////////////////////////////////////////////
///// Conn interface implementation of broken (malformed) connection ///////////
////////////////////////////////////////////////////////////////////////////////

type connMalformed struct{}

func (c *connMalformed) ID() string {
	return "<MALFORMED AND NOT INITIALIZED CONN>"
}

func (c *connMalformed) Context() context.Context {
	return context.Background()
}

func (c *connMalformed) WriteMessage(_ MessageType, _ []byte) {}
func (c *connMalformed) CloseWithCode(_ CloseCode)            {}
